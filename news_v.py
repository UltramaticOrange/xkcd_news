import imghdr
import logging
import requests
import argparse
from PIL import Image
from io import BytesIO
from flask import Flask
from news_c import XKCDNews
from base64 import b64encode
from functools import lru_cache
from news_consts import C, LogMessages

app = Flask(__name__)

# TODO: news_[mvc]: write a separte function that does all error handling for requests.get() calls


@lru_cache(maxsize=256)
def image64(url, img_tag=False, max_size=C.IMG_MAX_SIZE):  # 'img' is abbreviated to reflect the html <img /> tag.
    # TODO: image64: proxy config
    response = None
    try:
        # TODO: image64: The SSL certs for Debian Jessie haven't been updated since 2014. verify=False is temporary.
        response = requests.get(url, verify=False)
        if response and response.status_code != 200:
            raise requests.exceptions.ConnectionError
    except requests.exceptions.ConnectionError as e:
        logging.error(LogMessages.E_UNABLE_TO_FETCH % (response.status_code if response else '<timeout>', url))
        return None

    raw_image = response.content  # get the image to be manipulated
    image_type = imghdr.what(BytesIO(raw_image))  # returns an empty string if it can't be ID'd as a valid pic type.

    if image_type:
        try:
            image_obj = Image.open(BytesIO(raw_image))
        except IOError as e:
            logging.error(LogMessages.E_CORRUPT_IMAGE % url)
            return None
    else:
        logging.error(LogMessages.E_UNKNOWN_IMAGE_TYPE % url)
        return None

    # if the image is larger than a 125x125 thumbnail then resize it
    # if the user used 0 or None as the max size, preserve the original size.
    if max_size and (image_obj.size[0] > max_size or image_obj.size[1] > max_size):
        # It seems any errors generated by PIL should happen with open()
        image_obj.thumbnail((max_size, max_size), Image.ANTIALIAS)

        # a file-like object to hold the data in memory ... because PIL is an asshole that won't work with strings.
        fake_file = BytesIO()
        image_obj.save(fake_file, image_type.upper())
        fake_file.seek(0)
        raw_image = fake_file.read()

    b64image = 'data:image/%s;base64,%s' % (image_type, b64encode(raw_image).decode())
    return '<img src="%s">' % b64image if img_tag else b64image


@app.route('/robots.txt')
def robots():
    return '#Domo arigato, Mr. Roboto!'


@app.route('/favicon.ico')
def favicon():
    try:
        return open('rss.png').read()
    except IOError:
        return None


@app.route('/')
def news():
    try:
        template_file = open(C.HTML_TEMPLATE)
        html_template = template_file.read()
        template_file.close()
        if not html_template:
            raise IOError  # we want the same logic anyway, so /lazymode powers activated.
    except IOError as e:
        logging.warning(LogMessages.W_TEMPLATE_UNAVAILABLE % C.HTML_TEMPLATE)
        html_template = C.HTML_FALLBACK

    html = ''
    news_obj = XKCDNews()
    news_by_date = {}
    for site in news_obj:
        for story in site:
            # TODO: news: make date an item in consts so it's configurable-ish.
            normalized_date = story.date.to('America/Los_Angeles')
            body = C.HTML_DIV.format(**{C.CLASS:C.STORY_BODY, C.CONTENT:story.body})
            title = C.HTML_DIV.format(**{C.CLASS:C.STORY_TITLE, C.CONTENT:story.title})
            title = C.HTML_A.format(**{C.CLASS:C.STORY_TITLE, C.URL:story.url, C.CONTENT:title})
            date = C.HTML_PUBLISH_DATE.format(**{C.CLASS:C.STORY_PUBLISH_DATE, C.CONTENT:normalized_date})
            base64_image = image64(story.image) if story.image else ''
            image = C.HTML_IMG.format(**{C.CLASS:C.STORY_IMAGE, C.CONTENT:base64_image}) if base64_image else ''
            html_story = C.HTML_DIV.format(**{C.CLASS:C.STORY_WRAPPER, C.CONTENT:title+image+date+body})

            if normalized_date in news_by_date:
                news_by_date[normalized_date].append(html_story)
            else:
                news_by_date[normalized_date] = [html_story]
    keys = sorted(news_by_date)
    keys.reverse()
    for key in keys:
        html += ''.join(news_by_date[key])

    try:
        final_html = html_template.format(**{C.HTML_BODY:html, C.HTML_TITLE:'Top Headlines, a la XKCD!'})
    except KeyError:
        logging.error(LogMessages.E_TEMPLATE_MALFORMED)
        final_html = C.HTML_FALLBACK.format(**{C.HTML_BODY:html, C.HTML_TITLE:'Top Headlines, a la XKCD!'})

    return final_html


def main():
    print(news())

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-s', '--scr', dest='noDaemon', default=False,
                        action='store_true', help='Output to screen (for debugging)')
    parser.add_argument('-l', '--listen-on', dest='hostIP', default='127.0.0.1',
                        help='The IP on the host the service should listen on (e.g. 192.168.1.100).')
    args = parser.parse_args()

    if args.noDaemon:
        main()
    else:
        app.run(host=args.hostIP, threaded=True)

